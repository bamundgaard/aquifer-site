name: Build unified catalog manifest

on:
  workflow_dispatch:
  push:
    branches: [ main ]
    paths:
      - 'docs/**'
      - '.github/workflows/build.yml'
  schedule:
    - cron: '0 * * * *'  # hourly

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout site
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Generate manifest
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          BRANCH: main
          ORG_OR_USER: BibleAquifer   # account to crawl
          INCLUDE_FORKS: "false"
          INCLUDE_ARCHIVED: "false"
          PER_PAGE: "100"
          MAX_PAGES: "10"
          # Optional back-compat list; detection works without this
          LANGUAGE_FOLDERS_JSON: '["eng","fra","hin","por"]'
        run: |
          node - <<'NODE'
          const fs = require('fs');
          const https = require('https');

          const GH_TOKEN = process.env.GH_TOKEN;
          const BRANCH = process.env.BRANCH || 'main';
          const ORG_OR_USER = process.env.ORG_OR_USER;
          const INCLUDE_FORKS = (process.env.INCLUDE_FORKS || 'false').toLowerCase() === 'true';
          const INCLUDE_ARCHIVED = (process.env.INCLUDE_ARCHIVED || 'false').toLowerCase() === 'true';
          const PER_PAGE = Math.max(1, parseInt(process.env.PER_PAGE || '100', 10));
          const MAX_PAGES = Math.max(1, parseInt(process.env.MAX_PAGES || '10', 10));
          const EXTRA_REPOS = JSON.parse(process.env.EXTRA_REPOS_JSON || '[]');
          const LANGUAGE_FOLDERS = new Set(JSON.parse(process.env.LANGUAGE_FOLDERS_JSON || '[]')); // optional

          const IGNORE = [
            /^README(\.md|\.txt)?$/i, /^LICENSE(\.md|\.txt)?$/i,
            /^\.github$/i, /^\.gitignore$/i, /^\.gitattributes$/i, /^\.DS_Store$/i,
            /^index(\.md|\.html)?$/i
          ];

          const LANG_DIR_RE = /^(?:[a-z]{2,4})(?:[-_][a-z0-9]{2,8})?$/i; // en, eng, por, en-US, etc.

          function gh(path){
            const opts = {
              hostname: 'api.github.com',
              path,
              headers: {
                'User-Agent': 'aquifer-manifest-bot',
                'Authorization': `Bearer ${GH_TOKEN}`,
                'Accept': 'application/vnd.github+json'
              }
            };
            return new Promise((resolve, reject)=>{
              https.get(opts, res=>{
                let data=''; res.on('data', d=>data+=d);
                res.on('end', ()=>{
                  if(res.statusCode>=200 && res.statusCode<300){
                    try { resolve(JSON.parse(data)); } catch(e){ reject(e); }
                  } else {
                    reject(new Error(`GitHub ${res.statusCode}: ${data}`));
                  }
                });
              }).on('error', reject);
            });
          }

          async function listAllReposForAccount(account){
            const out = [];
            async function pull(base){
              for (let page=1; page<=MAX_PAGES; page++){
                const path = `${base}?per_page=${PER_PAGE}&page=${page}`;
                const batch = await gh(path);
                if (!Array.isArray(batch) || batch.length === 0) break;
                out.push(...batch);
                if (batch.length < PER_PAGE) break;
              }
            }
            try { await pull(`/orgs/${account}/repos`); }
            catch { await pull(`/users/${account}/repos`); }
            return out;
          }

          function isIgnored(name){ return IGNORE.some(re => re.test(name)); }

          async function listDir(owner, repo, path=''){
            const enc = path ? `/${encodeURIComponent(path).replace(/%2F/g,'/')}` : '';
            const out = await gh(`/repos/${owner}/${repo}/contents${enc}?ref=${BRANCH}`);
            return Array.isArray(out) ? out : [out];
          }

          async function walk(owner, repo, basePath){
            const acc = [];
            async function recur(p){
              const items = await listDir(owner, repo, p);
              for (const it of items){
                if (it.type === 'dir') {
                  if (isIgnored(it.name)) continue;
                  await recur(it.path);
                } else if (it.type === 'file') {
                  if (isIgnored(it.name)) continue;
                  acc.push({
                    path: it.path,
                    size: it.size ?? null,
                    sha: it.sha ?? null,
                    downloadRaw: `https://raw.githubusercontent.com/${owner}/${repo}/${BRANCH}/${it.path}`,
                    downloadCdn: `https://cdn.jsdelivr.net/gh/${owner}/${repo}@${BRANCH}/${it.path}`
                  });
                }
              }
            }
            await recur(basePath);
            return acc;
          }

          function isLanguageDirName(name){
            // Accept configured names OR regex match for plausible language codes
            return LANGUAGE_FOLDERS.has(name) || LANG_DIR_RE.test(name);
          }

          (async ()=>{
            // 1) Expand account into repos
            const reposFromAccount = await listAllReposForAccount(ORG_OR_USER);
            const baseRepos = reposFromAccount
              .filter(r => (INCLUDE_FORKS || !r.fork))
              .filter(r => (INCLUDE_ARCHIVED || !r.archived))
              .map(r => ({ name: r.full_name }));

            // 2) Merge with any EXTRA_REPOS entries
            const REPOS = [...baseRepos, ...EXTRA_REPOS];

            // 3) Build manifest
            const manifest = { generatedAt: new Date().toISOString(), repos: [] };

            for (const cfg of REPOS){
              const [owner, repo] = cfg.name.split('/');

              if (cfg.autodiscover){
                try {
                  const root = await listDir(owner, repo, '');
                  const topDirs = root.filter(x => x.type === 'dir' && !isIgnored(x.name)).map(x => x.name);
                  const languages = { [cfg.asLang || '_datasets']: [] };
                  for (const dir of topDirs){
                    const files = await walk(owner, repo, dir);
                    languages[cfg.asLang || '_datasets'].push(...files);
                  }
                  manifest.repos.push({ name: cfg.name, branch: BRANCH, languages });
                } catch (e){
                  console.warn(`WARN autodiscover failed for ${cfg.name}: ${e.message}`);
                }
                continue;
              }

              // Standard: detect language folders dynamically
              try {
                const root = await listDir(owner, repo, '');
                const languages = {};
                for (const item of root){
                  if (item.type === 'dir' && isLanguageDirName(item.name)) {
                    languages[item.name] = await walk(owner, repo, item.name);
                  }
                }
                if (Object.keys(languages).length){
                  manifest.repos.push({ name: cfg.name, branch: BRANCH, languages });
                }
              } catch (e){
                console.warn(`WARN listing failed for ${cfg.name}: ${e.message}`);
              }
            }

            fs.mkdirSync('docs/data', { recursive: true });
            fs.writeFileSync('docs/data/manifest.json', JSON.stringify(manifest, null, 2));
            console.log('âœ… wrote docs/data/manifest.json with', manifest.repos.length, 'repos');
          })().catch(err=>{ console.error(err); process.exit(1); });
          NODE

      - name: Auto-commit manifest
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "Update unified catalog manifest [skip ci]"
          file_pattern: docs/data/manifest.json
